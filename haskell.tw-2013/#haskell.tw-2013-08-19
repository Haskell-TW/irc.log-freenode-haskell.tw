10:07:48 <GH_J_> 有人用 linux 的嗎
10:07:51 <GH_J_> ...
10:08:03 <favonia> GH_J_: ??
10:08:07 <favonia> GH_J_: （舉手）
10:08:13 <GH_J_> 拿來這裡問好像很奇怪＠＠
10:08:30 <GH_J_> 我好不容易裝了 網卡驅動
10:08:48 <GH_J_> 但是無線的跟有線的卻無法並存
10:08:56 <GH_J_> 苦惱...
10:09:56 <Yu-Lin> 咦？
10:09:58 <b4283> 這個你應該去你用的 distro 頻道問哪
10:10:00 <Yu-Lin> 哪個發行版？
10:10:15 <GH_J_> debian
10:10:24 <GH_J_> 沒人 呢＝＠＝
10:10:35 <GH_J_> 連裝 driver 都搞了好幾天 ...
10:10:57 <Yu-Lin> 7?
10:11:10 <GH_J_> 這我也不知道＠＠
10:11:15 <GH_J_> 他是 debian-base
10:11:20 <GH_J_> 需要 uname
10:11:24 <GH_J_> 嗎？
10:11:49 <GH_J_> 還以為設定的問題 ...
10:13:05 <GH_J_> 變成一開進去就要重裝 其中一個driver
10:13:11 <GH_J_> 才會並存
10:13:22 <GH_J_> 一重開 有一個就會失效
10:13:28 <favonia> GH_J_: sorry 剛才有事情要先處理
10:13:38 <GH_J_> favonia, @@
10:13:54 <GH_J_> favonia, 要緊事先處理 ～
10:14:06 <favonia> GH_J_: 我也覺得好像有更適合的頻道 lol
10:14:22 <favonia> GH_J_: 為什麼有線和無線會無法並存....
10:14:41 <GH_J_> 我先裝好 有線的 driver
10:14:47 <GH_J_> 然後在裝 無限的
10:14:51 <GH_J_> 無線
10:14:57 <GH_J_> 重開機
10:15:07 <GH_J_> 有線的就不見
10:15:15 <GH_J_> 但是重裝就有了
10:15:23 <GH_J_> 兩個都可以正常連線
10:16:47 <Yu-Lin> 你可以去 #debian 問問看
10:17:04 <mno2> #debian ++
10:18:24 <GH_J_> #debian 有白名單？
10:18:35 <GH_J_> 用 xchat 他說我被 ban ...
10:18:51 <GH_J_> 網頁版的就進去了 ..
10:20:50 <b4283> GH_J_: #debian-zh
10:21:35 <GH_J_> invite only channel ...
10:21:54 <b4283> 啊，不對，那個是在 irc.debian.org ，不是在這裡
10:23:18 <GH_J_> oh~
12:14:28 <mno2> 真希望 go 現有實作有 byte code，我覺得他的 runtime 看起來蠻棒的，但不太喜歡語言本身 xD
12:15:51 <_13h> 可以做 altgo XD
12:17:49 <mno2> altgo 是？
12:18:36 <_13h> 就跟 altjs 差不多意思，我亂掰的XD
12:21:29 <_13h> mno2: https://github.com/fglock/Perlito  可以寫 perl 6 再轉成 go XD
12:22:23 <mno2> 喔喔
15:03:01 <drbean> #dot on irc.oftc.net
15:51:30 <Yu_lin> 想問一下 SECD
15:52:14 <Yu_lin> 從 wiki 的資料來看，這要怎麼找出 list 中第一筆資料？
15:52:34 <mno2> suhorng 不在 xD
15:52:50 <Yu_lin> 果然還是要招喚 suhorng XD
15:56:54 <petercommand> topic
15:57:10 <petercommand> 打錯XD
15:59:55 <Yu_lin> ?
16:00:02 <_13h> Yu_lin: 你是說類似 car 的結果嗎?
16:01:04 <Yu_lin> 不是耶，我是想知道當我 car (1, 2, 3) 時，怎麼找到 1 這個位置
16:02:51 <Yu_lin> 例如 address 2 [ list    | 1 | 6 ] 標示了 car 跟 cdr 的位置，但 secd 是怎麼知道 address 2 是這個 list 的第一位
16:06:10 <_13h> 不太懂  這個 address 2 就是要你自己寫給 car 的啊
16:06:39 <_13h> 以 cons cell 的結構來說，每個節點都有可能當作頭吧?
16:07:32 <_13h> 我的想法是這樣，你光是看 address 2 是沒意義的，你把 address 2 丟給 car，那它就是頭.... 你的問題是這個嗎?
16:11:03 <_13h> Yu_lin: 阿  我想了一下，你的問題該不會是，當程式出現 car (1 2 3) 時，怎麼找到 (1 2 3) 是從 address 2 開始?
16:11:28 <Yu_lin> 阿，對，是這樣沒錯XD
16:12:23 <_13h> 我覺得方向可能會是倒過來的，當程式看到 car (1 2 3) 時，會先去造出一個 (1 2 3) ，然後把造好的位址丟給 car
16:13:42 <_13h> 以 wikipedia 的例子來說，建構了一個新的 list 放在 address 1 ~ 9, 然後把 address 2 丟給 car
16:14:54 <Yu_lin> 的確是一種解決方式，不知道還有沒有其他做法
16:15:22 <_13h> 如果記憶體中已經出現過 (1 2 3)，程式找得到嗎？沒有 tag 或 hash 的話，要比對兩個物件是不是相等的話，直接用 secd 做應該很麻煩...
16:16:55 <_13h> 我猜像一般的動態語言只會 cache 簡單的物件，像 python 就是 cache 簡單的數字和字串 (但不是全部的數字 字串都會 cache 起來)
16:17:24 <_13h> 像 list 這種有可能很複雜的東西，可能就看到一次建一次吧@_@
16:25:10 <Yu_lin> 這方法又讓我想起 forth 阿XD
16:25:52 <_13h> 唔.. 沒辦法，剛剛回答的人是玩 forth 的XD
16:26:26 <Yu_lin> 難怪XD
16:26:50 <_13h> 不過我也蠻好奇像 haskell 這類語言遇到一樣的 list 會共用嗎？還是再建一個新的出來?
16:27:59 <Yu_lin> 這是一個 (1) == (1) 的問題XD
16:28:28 <_13h> 就算你想比對系統中是不是已經出現過同樣的 list ，並重複使用好了，parse 後的 ast 還是需要變成一個 list，才能去系統裡把所有的 list 撈出來比對啊，我覺得就效率來說好像不太好...
16:29:45 <_13h> 不過如果是在程式碼寫死的 list (例如 (1 2 3))，應該都是 compile time 就可以處理好的問題?
16:30:30 <_13h> 頂多就是編譯時多花點時間搞一些節省記憶體的動作，讓執行時可以省一點?
16:35:20 <_13h> Yu_lin: 我在 python 裡試了一下，如果你用 (1,)，那每次都會參考到同一個物件，但你弄個複雜一點的 (1,2)，每次都會產生新的
16:35:56 <Yu_lin> 這樣要驗證 (1,2) = (1,2) 超麻煩的XD
16:38:34 <_13h> 印象中以 python 的做法來說，雖然是不同物件，但是可以算出同樣的 hash 值，所以 == 就直接比 hash 就好
16:41:33 <Yu_lin> 結構跟資料都相同，所以有辦法這樣用吧？
16:41:59 <Yu_lin> secd Orz|||
16:42:14 <_13h> 應該就是看 hash 怎麼算吧?
16:44:41 <_13h> 好吧  實驗了一下可能不是單純比 hash 而已，我弄了兩個物件，但騙 python 有相同 hash 值，== 會傳回 false XD  一般設計 == 有什麼好方法嗎?
17:12:58 <hashcat> 無聊打岔個跟程序無關的東西, 但可能還是有關
17:17:24 <Yu_lin> 嗯？
17:17:35 <hashcat> 量子系統製造一堆paradox, 為了化解這些謬論, 有著一堆詮釋
17:17:46 <hashcat> 其中有一個叫閉嘴計算詮釋
17:18:28 <hashcat> 就是別管了, 計算就對了
17:22:36 <hashcat> _13h: 兩個東西是否相等, 有個說法是當他所有可觀察量測的行為或特性一樣時, 那兩者就是相等
17:23:23 <_13h> 這就看定義囉  你看 lisp 定義了好幾種不同的比較方式
17:23:47 <_13h> 有比較是不是同一個的，也有比較值是不是一樣的
17:23:55 <hashcat> 就是把每個方法和欄位叫出來吧
17:24:07 <hashcat> hash相等法有很大條的問題
17:24:49 <hashcat> hash碰撞時, 連兩個相同hash的物件, 近似也沒保證
17:25:38 <_13h> 也許比較的策略可以加強一點，例如 hash 相等時再比一下其他東西?
17:25:47 <hashcat> 如果單是把近似的兩個東西看作相等, 還可以估計上下界
17:26:00 <_13h> 但至少 hash 不同的時候就可以視為不同了吧? 不用再繼續比下去
17:26:23 <hashcat> hash誤差就完全噴飛
17:26:45 <hashcat> 取名hash不相等法
17:27:28 <hashcat> 但計算hash不會有直接比較快吧
17:28:46 <hashcat> hash -> 比較 -> 證成不相等, 比較 -> 能證成相等或不相等
17:31:28 <hashcat> 這命題成立, 變數指向記憶體相等 -> 變數值相等,
17:32:34 <hashcat> 要比較兩物件是否相等, 指向記憶體相等就不用繼續遞迴深下去, 記憶體不相等才遞迴下去
17:43:52 <_13h> 唔，我的問題是，若比較記憶體相等的話，要怎麼比? 萬一是個 mutable ，有可能裡面的東西已經變啦，或者是內部的某個值已經不一樣了
17:46:03 <Yu_lin> 如果能定義這個記憶體位置是 mutable 或 immutable，後面再來選比較方法呢？
17:46:36 <_13h> 當然也可以啊
17:47:00 <_13h> 但這樣就需要多花一點空間記錄了
17:48:04 <hashcat> 那表示你作比較的時間跟數值變動的時間很接近
17:48:23 <hashcat> 才會有這問題
17:48:57 <hashcat> 你就當成是硬體內在的時間誤差就好了
17:52:00 <hashcat> 記憶體作法是等待一個動作完成才准許下個動作, 但這樣對平行化不利
17:52:58 <hashcat> 比較的動作時會影響的物件都應該早被鎖定了
17:54:16 <_13h> 總覺得這說法有點怪，不過說不太出來是什麼問題XD
17:54:23 <hashcat> 或者用software transactional memory 這種模型
17:55:39 <hashcat> 反正同時兩個動作進行, 並且兩個動作的先後會有影響, 就會有機制保證所謂"同時動作"不會有每次不同的結果
17:56:02 <hashcat> 避免內在的時間誤差
17:59:43 <hashcat> 這是concurrency的問題
18:00:11 <hashcat> 若是一段時間只能分配進行一個動作,不會有這問題
18:02:10 <hashcat> 你就想若是等比較完成後, 才能進行改變值得動作, 或者反過來值改變完成後, 才能進行比較動作
18:02:16 <hashcat> 那問題就消失拉
18:02:43 <_13h> 只比較記憶體位址的話，感覺像是 identity，不是 equality 或 equivalent ?
18:03:11 <_13h> 唔.. 名詞應該是 equivalence
18:03:41 <hashcat> 然後有種機制是在兩個動作同時進行時, 保證前後一致
18:04:26 <hashcat> 記憶體一個時刻只能有一種值這無可爭議吧
18:05:36 <CindyLinz> hashcat 正在討論 hash 的問題.. (Y)
18:06:19 <hashcat> 不然換另一種說法, 你若是比較到一半突然停下來停下來, 然後進行改變數值的動作, 然後才繼續進行比較動作
18:06:52 <hashcat> 這是一個全新的程序, 不同於原來先比較後改值, 也不同於先改值後比較
18:07:25 <hashcat> STM跟LOCK這種Concurrency機制, 就是在避免這種全新程序跑出來
18:07:59 <hashcat> CindyLinz: 不是在討論比較兩物件相等的問題嘛
18:09:31 <CindyLinz> hashcat: 還沒細看嘛.. 只是看到一堆 hash 字樣飛來飛去 :p
18:09:56 <CindyLinz> 剛剛都在開會啊 ._.
18:10:10 <hashcat> 我這無業遊民還真悠閒
18:10:26 <Yu_lin> CindyLinz: 故事要從 SECD 說起
18:10:54 <CindyLinz> 不急不急, 我等下要先回家 ._.
18:10:59 <hashcat> 我也是一半才插進來, 一開始不知道在講啥
18:11:04 <CindyLinz> 只是切窗路過一下
18:11:07 <Yu_lin> -> 資料比較 -> hash -> 記憶體 -> concurrecy
18:11:28 <hashcat> hash是多此一舉阿
18:11:36 <hashcat> 比較已經比較了全部
18:11:48 <hashcat> hash也是要把資料全部跑過
18:12:07 <hashcat> 而且損失了一些資訊
18:12:14 <CindyLinz> hash 是為了 heuristic, 快快把一定不一樣的東西去掉?
18:12:41 <hashcat> 問題是hash的時間沒有比較少
18:13:16 <CindyLinz> hash 值是沒有 cache 起來的?
18:13:23 <hashcat> 從位元組的角度看比較是線性的, hash卻多了一堆步驟
18:13:28 <CindyLinz> cache 起來好像很難做 orz
18:13:46 <hashcat> 而且hash後只能確定兩者不相等, 沒辦法確定兩者是否相等
18:14:05 <CindyLinz> 對, 在通常不會相等的時候可能有賺
18:14:17 <hashcat> 但直接比較在某個位元不相等時就可以停下來確定不相等
18:14:33 <hashcat> 全部相等時就能斷定相等
18:14:51 <hashcat> 所以用hash貌似沒有什麼好處
18:16:59 <hashcat> 密碼之所以會用那玩意, 主要還是碰撞機率夠低跟非明文儲存兩特性吧
18:17:46 <hashcat> 還有硬碟消耗
18:19:21 <hashcat> 密碼也不算是很常改變的東西, 這種trade-off還說得過去
18:19:38 <hashcat> 單純比較相等還是直接比較比較快吧
19:09:26 <Yu_lin> 回家了
19:55:00 <favonia> _13h: 高階語言不該管 (1,2,3) 和 (1,2,3) 底層是不是真的同一個...
19:57:41 <favonia> _13h: (1,2,3) 的意義就是 (1,2,3)... 沒別的了。高階語言不定義底層到底怎麼做的。
19:58:15 <favonia> _13h: 但我們可以來討論底層在某個計算機架構下要怎麼實作比較對
19:58:21 <favonia> 或比較快
19:58:42 <favonia> 可是高階語言裡面不應該有方法可以區辨這些實作
20:19:15 <letoh> favonia: 對  其實剛剛主要是在說實際上的實作是怎麼處理
20:20:28 <letoh> 啊  不過「是不是真的同一個」這件事我還是有點問題  在語言層可以完全都不需要這個行為嗎?
20:21:02 <favonia> letoh: 不需要。需要檢討的是「比較」這件事情
20:21:21 <letoh> 雖然我平常也不太管，不過例如在寫 python 時，就常常要寫出 if item is None: xxx  這種程式碼
20:22:07 <favonia> letoh: 這種就只是 case 而已
20:22:41 <favonia> letoh: 我假設你剛才的意思是說程式語言不需要內建一個「萬用 ==」。的確是不需要啊，實際上也做不太到。
20:22:58 <letoh> 嗯嗯
20:24:17 <favonia> letoh: 那些有萬用 == 的多多少少都有問題
20:24:40 <favonia> 特別是函式之間的比較
20:24:49 <letoh> 應該也還不到萬用啦  例如說在 pattern matching 時，怎樣算 match 到? 這會需要一個萬用的 == 嗎?
20:25:02 <favonia> letoh: "case" 是內建的
20:25:21 <favonia> 你是說底層怎麼實作嗎
20:25:24 <letoh> 對
20:25:30 <letoh> 語言是內建的我知道呀
20:25:54 <favonia> 就慢慢比吧
20:26:28 <letoh> 唔，所以像下午講的那些比較 hash 或比較 address 之類的策略有幫助嗎?
20:27:13 <letoh> 不過對 pattern matching 來說，常常需要拆資料比較，有個 hash 值可能幫助不大?
20:27:49 <favonia> 不知道耶 如果他們想要實作這種最佳化也可以吧
20:45:16 <favonia> letoh: 我平常沒有在注意 orz
20:50:31 <b4283> 實際上在剛剛的討論中我腦袋一直浮現 scheme 的 eq? eqv? equal?  XD
20:52:31 <letoh> favonia: 高階人XD
20:53:06 <letoh> b4283: 其實我也一直都是基於那幾個在討論XD
20:53:53 <b4283> 「高階人」會讓我想到鋼彈的某個名詞
20:54:04 <letoh> 什麼名詞?
20:54:58 <b4283> 新世代還什麼的
20:55:10 <b4283> 一時想不起來
20:55:18 <favonia> b4283: 萬用 == 很麻煩啊...
20:55:57 <favonia> b4283: 很難定清楚
20:56:11 <favonia> b4283: 你試著想想。如果要用數學把一切都講清楚
20:56:30 <favonia> (cons a' b') 不只是我現在寫的這個字串 "(cons a' b')"
20:56:38 <letoh> b4283: 你是說 ニュータイプ 還是 コーディネーター 之類的嗎?
20:56:56 <favonia> 還要建立一個（抽象的）記憶體，說明這串東西存在哪裡
20:57:10 <b4283> 對啦！newtype
20:57:18 <letoh> 要分那麼多種應該還是因為有實際的需求吧?
20:57:23 <favonia> 才能正確的講清楚 Scheme 的語意
20:58:14 <b4283> 也就是說 scheme 的語意暗示某種 memory model
20:59:40 <b4283> letoh: 實際上應該和會有 bytevector 是一樣的存在理由
21:00:42 <b4283> 如果你知道你的東西是什麼，用 eq? 比就是比較快 XD
21:01:10 <letoh> 用工人智慧做最佳化?
21:01:13 <b4283> (純屬個人猜測 XD)
21:01:20 <favonia> b4283: 不完全是這樣。標準說 This relation is left slightly open to interpretation
21:01:46 <favonia> b4283: 他只有說什麼時候一定一樣什麼時候一定不一樣
21:02:20 <b4283> favonia: yeah, 上次你說到字串我有去翻一下
21:03:06 <b4283> 比較奇妙的是它解說的順序是 eqv -> eq -> equal
21:04:21 <favonia> b4283: 這個很不幸很容易違反「無法區分實作」的特性... 甚至大家誤以為 eq? 一定要依照什麼記憶體之類的
21:05:23 <favonia> b4283: 萬用 == 最大罩門就是函式。即使是 equal? 對於函式也是沒輒。（因為本來就不該比啊...）
21:06:22 <favonia> b4283: 嚴格來說不只函式啦，但一般語言大概就是函式了。
21:06:31 <b4283> 我就是以為 eq 和記憶體有關的人 (遮臉)
21:08:55 <favonia> b4283: 如果要定成跟記憶體有關也可以。只是要嚴謹講清楚就更煩了...
21:09:13 <favonia> b4283: 我認為根本解決之到就是承認不是所有資料都可以比較這樣
22:15:55 <CindyLinz> favonia: 數學上.. 如果定義域是有限集合的函數, 還是可以比吧?
22:17:14 <CindyLinz> 嗯, haskell 如果實作要把遇到的相同的 list 都用同一個, generic 來說好難做啊 XD
22:17:23 <CindyLinz> haskell 有無窮 list 耶~
22:17:47 <CindyLinz> 如果我來做的話, 頂多就嘗試性地搜尋有限的幾層吧
22:18:09 <CindyLinz> 而且搜尋的過程還必須有類似 compute 幾步就必須放棄之類的設計
22:18:27 <CindyLinz> 不然如果搜尋過程踩到原有程式不會踩到的 bottom 就囧了..
22:24:43 <favonia> CindyLinz: 數學上不一定有限才能比。
22:24:56 <CindyLinz> 嗯, 我只是舉一個安全一點的例子 :p
22:25:31 <CindyLinz> 一開始想說.. 數學上對函數相等是有定義的, 就是 input / output 的 set 一樣, 而且每一個 input 都會對到同一個 output
22:25:42 <CindyLinz> 可是這樣好像不是直構式做得出來的 XD
22:26:19 <favonia> 你可以這樣定義，但證不證得出來是另外一回事
22:26:24 <favonia> 定義本身沒有什麼問題啊
22:26:26 <CindyLinz> 喔也是 XDD
22:29:29 <hashcat> 函數或程序的相等可以化約為演算步驟一致
22:30:46 <CindyLinz> 程式碼一樣?
22:31:16 <hashcat> 我比較想說可計算函數
22:31:46 <hashcat> 像是在combinator logic, 定義相等就不一定是從輸出入來看
22:32:45 <hashcat> SKK跟I, 相同的輸入會有相同的輸出, 但SKK在沒有輸入的狀況下沒辦法化約成I
22:33:19 <hashcat> 根據上下文有時這兩種就被算作不相等
22:35:12 <hashcat> 因為語言的關係, 程序的相等很難說是啥嚜玩意
22:35:39 <hashcat> 形式的模型,像是Mu遞歸函數,就比較好說
22:36:25 <CindyLinz> 實用性大不大啊?
22:36:54 <favonia> hashcat: "通常"函數的相等用外延啦... xD
22:37:11 <CindyLinz> 我心中隨意想想的實際用途, 好像都可以用比較簡單的模式: 使用者在函數上面套一層 ref
22:37:28 <CindyLinz> 然後就比較 ref 有沒有相等這樣
22:38:58 <hashcat> favonia: 在lambda calculus還要有eta縮約, 外延才能證成
22:41:09 <hashcat> 有好幾種不同的相等
22:42:15 <hashcat> 以後有複製人, 兩個同基因的人, 跟真的是同一個人也有不同的相等暈
22:42:53 <favonia> hashcat: lambda calculus 不需要 eta 就可以定相等啊
22:43:23 <favonia> hashcat: 我是說外延的定法
22:43:47 <CindyLinz> 這句聽起來好禪.. # 外延才能證成
22:44:07 <favonia> hashcat: 等一下讓我仔細想一下...
22:44:13 <hashcat> ??
22:45:18 <favonia> hashcat: 不需要 eta. 你可以不靠 eta rule 定義「相等」
22:45:32 <hashcat> 外延性需要吧
22:45:38 <favonia> 不需要...
22:46:11 <hashcat> (\x -> f x) 不管不管用 alpha 還是 beta 都沒辦法變成 f 不是?
22:47:08 <favonia> 可是相等不一定要用 reduction 定義啊。你講的可能是另外的東西... 而且很多定理都要有 type 才行。
22:47:24 <favonia> 你可以定相等，只是定出來的相等可能不包含 eta equivalence
22:47:52 <hashcat> 我才說有好幾種不同的相等
22:48:59 <favonia> 我的意思是相等的定義本身不需要 eta rule... 除非你說 eta "根據定義"相等，而且你用 reduction
22:49:45 <favonia> 但這樣比較像是你用 eta rule 來定義相等，而不是「相等」這個概念本身需要 eta rule
22:51:11 <hashcat> 我貌似只說外延要用eta縮約
22:52:15 <hashcat> 像是對我來說英國人跟法國人看起來都一樣
22:52:52 <hashcat> 但英國人跟法國人會否認彼此是一樣的人
22:55:04 <favonia> hashcat: 我不確定我了解你的意思。你的意思是說如果要用外延來理解程式，例如程式 p 和 q, 那就一定要 p 和 q 都運算至符號相同的程式 r 這樣嗎
22:55:19 <hashcat> 不是
22:55:40 <hashcat> 是說相等根據上下文可以有好幾種定義
22:55:58 <hashcat> 然後舉例外延不一定會是相等的必要條件
22:56:38 <favonia> 嗯... 你「外延」的意思是？
22:56:40 <hashcat> 順便說項mu遞歸函數會比直接比較程序容易
22:57:57 <hashcat> SKK和I就是外延相等但因為形式不同沒法彼此化約, 所以有些狀況會把他們定義成不相等
22:59:16 <hashcat> 外延相等: 兩個程序, 若兩個輸入相同, 則兩個輸出相同
23:01:58 <favonia> 讓我想一下。可是如果要說明這個，不就要舉一個相等的定義，而且「外延不同但"相等"」的例子才能說明外延不是必要條件？
23:03:28 <hashcat> 外延不是相等的必要條件是說, 相等不一定包含外延
23:05:00 <favonia> 好吧。如果是我的話我會說「充份條件」...
23:05:52 <hashcat> 那樣就變成外延就可以定義相等了
23:06:22 <hashcat> 就少討論沒外延的相等
23:07:10 <favonia> 我的意思是說，如果要描述「相等不一定包括外延」我會用「外延不是相等的充份條件」，而不是我本身贊同或反對這個描述。
23:09:34 <hashcat> 我覺得你搞錯充分跟必要拉
23:10:47 <favonia> hashcat: er... "A 是 B 的充份條件" = "A -> B" = "B 包含 A" 不是嗎
23:10:50 <hashcat> A -> B , A belong to B , A是B充分條件, B是A必要條件
23:11:06 <favonia> 不是，不是 A belongs to B
23:11:34 <favonia> B, 作為一個 relationship, 包含比 A 更多的東西
23:11:37 <hashcat> A belongs to B 不就是B包含A
23:12:02 <favonia> 但不是 B 的 member
23:12:06 <favonia> 是 B 的 subset
23:12:08 <hashcat> 我有講錯應該說 A is a subset of B
23:14:07 <favonia> 那 A = "外延", B = "相等" 的話。 "B(相等)包括A(外延)" 不就是 "A(外延)是B(相等)的充份條件" 嗎 @@?
23:22:19 <hashcat> 相等不一定能導出外延是說 非 相等 -> 外延 , 非 外延是相等必要條件
23:24:55 <favonia> 我只有說「相等不一定包括外延」沒有說過「相等不一定*導出*外延」...
23:25:48 <hashcat> 相等不一定包括外延 => 非 (相等包括外延) => 非 (外延 is a subset of 相等) => 非 (外延 -> 相等)
23:26:44 <favonia> => 非 (外延是相等的充份條件) => 外延不是相等的充份條件
23:29:47 <favonia> CindyLinz: 趁機看到你回我 Perl 的評論 lol 好吧我好像可以接受這種解釋。
23:29:53 <hashcat> 我貌似搞錯啥嚜了
23:30:22 <favonia> CindyLinz: 不過上次比賽時還是有人中招... orz 我猜大概是沒有加 my
23:32:15 <favonia> hashcat: hmm 我想表達的只是說，我沒記錯的話有一些奇妙的「相等」定法，有包含 eta, 但定義本身不需要 eta 縮約
23:32:51 <hashcat> 我應該是想說外延不一定是定義相等必要的
23:32:54 <favonia> hashcat: 但對於 untyped lambda calculus 我比較沒把握 orz 太多奇怪 cases 了 orz
23:33:34 <favonia> hashcat: 喔那我同意。的確不需要這樣定。
23:34:05 <hashcat> 結果被必要誤導成必要條件@@
23:34:16 <favonia> @@
23:34:48 <favonia> CindyLinz: 讓我覺得「實務上」還是有長期 Perl 寫手會因為這種問題中招啊...
23:35:18 <favonia> CindyLinz: 雖然可能不是 my/local 就是了
23:36:13 <hashcat> 但A不是必要的, 跟A不是必要條件聽起來很通順
23:36:18 <hashcat> 奇怪了唉
23:37:58 <favonia> hashcat: 讓我想起每次 sound/complete 都要講清楚誰對誰 sound
23:39:05 <favonia> CindyLinz: 喔天啊，我猜是 recursion 的問題 orz
23:40:17 <hashcat> 之前說 "相等不一定能導出外延是說 非 相等 -> 外延 , 非 外延是相等必要條件"
23:42:39 <hashcat> 後來又說 相等不一定包含外延是說 非 (外延 is a subset of 相等) => 非 (外延 -> 相等) => 外延不是相等充分條件
23:43:38 <hashcat> 相等不一定能導出外延,  相等不一定包含外延 聽起來又傻眼地一樣
23:44:24 <hashcat> @@@@
23:48:32 <hashcat> 我知道問題在哪拉
23:48:58 <hashcat> A跟B相等是命題不是集合
23:49:21 <hashcat> 所以 "相等不一定包含外延" 不能講出來哈哈
23:50:47 <hashcat> 講完整就是：(A跟B相等) 不一定能導出 (A跟B會有一樣的外延)
23:51:28 <favonia> hashcat: 嗯嚴格來說是這樣啦，不過通常可以當作 {(A,B) | A "=" B} 這個集合
23:52:41 <hashcat> (A跟B會有一樣的外延)不是(A跟B相等)的必要條件
23:53:07 <hashcat> 感覺像是我以為我講得兩種相等是一樣的詞才搞混
23:53:22 <hashcat> 不是被必要條件跟必要誤導, 這沒問題
23:54:39 <hashcat> 開始是你沒弄清楚這點, 我聽了也沒弄清楚也誤導過去
23:54:49 <hashcat> 結果講出完全不一樣的命題
23:55:00 <hashcat> 解決了暈
23:58:18 <favonia> hashcat: 在「一般」數學裡面 equivalence 是理解成 {(A,B) | A "=" B} 這個集合... 所以這兩個其實並沒有什麼差別 @@
23:59:58 <hashcat> 我另一種說相等不一定包含外延, 本意應該是指相等的定義句子中不一定會包含外延的要求
